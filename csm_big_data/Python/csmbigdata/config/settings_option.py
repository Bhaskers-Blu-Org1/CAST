#!/bin/python
# encoding: utf-8
#================================================================================
#   
#    settings_option.py
# 
#  Â© Copyright IBM Corporation 2015,2016. All Rights Reserved
#
#    This program is licensed under the terms of the Eclipse Public License
#    v1.0 as published by the Eclipse Foundation and available at
#    http://www.eclipse.org/legal/epl-v10.html
#
#    U.S. Government Users Restricted Rights:  Use, duplication or disclosure
#    restricted by GSA ADP Schedule Contract with IBM Corp.
# 
#================================================================================ 
'''
.. module:: csmbigdata.config.settings_option
    :platform: Linux
    :synopsis: TODO
.. moduleauthor:: John Dunham (jdunham@us.ibm.com)
'''
import configparser
import logging
logger = logging.getLogger(__name__)

class SettingsOption(object):
    ''' Defines an option to either the commandline or a config parser file. '''

    def __init__(self, 
        short_name = None, 
        long_name = None, 
        config_name = None, 
        default = None,
        description = "", 
        arg_pattern = "", 
        parse_funct = None, 
        subsection_funct = None,
        is_flag = False):
        ''' Initializes the SettingsOption, this should be invoked when building the map. '''

        #: The short name of the element on the command line.
        self.short_name = short_name
        
        #: The long name of the element on the command line.
        self.long_name = long_name 
        
        #: The name of the element in a config file.
        self.config_name = config_name
        
        #: The default value of the element.
        self.default     = default
        
        #: The description of the element.
        self.description = description
        
        #: The pattern of the argument, used for help and error messages.
        self.arg_pattern = arg_pattern
        
        #: The function to parse the argument with. 
        #:
        #: Function has the following format: **parse_funct(string)**
        self.parse_funct = parse_funct
        
        #: A function to be invoked if a config value points to other subsections.
        #:
        #: Function has the following format: **subsection_funct(string, configparser)**
        self.subsection_funct = subsection_funct
        
        #: Sets whether this element is a flag or not, if set this flag will
        #: set the attribute flag to True.
        self.is_flag = is_flag

        # Default the default for this element to false if this is a flag.
        if self.is_flag and type(self.default) is not bool:
            self.default = False
        
    def get_help_string(self, description_offset, description_width, option_offset, option_width):
        ''' Generates a health string constrained to the width and offset parameters supplied. This help string will be terminated with a newline character.
        A help string generated by this function will look something like this:

        .. code::

           Description Text
           Can be multilne w-
           ith spilt tokens:        -a, --argument {arg_pattern}

        The constraints correspond the following characters:
        
        | - : `description_offset`
        | + : `description_width`
        | ^ : `option_offset`
        | @ : `option_width`
        | ---+++++++++++^^^^^^@@@@@@@@
        
        :param int description_offset: The offset of the description paragraph, in characters.
        :param int description_width: The width of the description, in characters.
        :param int option_offset: The offset of the arguments/options in the help string
            from the description paragraph, in characters.
        :param int option_width: The width of the arguments/options paragraph, in characters.

        :returns string: A help string for this element constrained to the screen dimensions supplied and terminated with a newline. 
            If a help string can't be generated,  "" is returned.
        '''
        # EARLY RETURN if commandline only.
        if self.short_name is None and  self.long_name is None:
            return ""

        # The help string for the element. 
        help_string, last_width, desc_lines = self.constrain_string(
            self.description, 
            description_width, 
            description_offset) 
        
        # offset the option section
        help_string += ":" + " " * ( option_offset + (description_width - last_width) )

        # Build the option string then make it fit the screen
        option_string = ""
        if self.short_name is not None:
            option_string += "-" + self.short_name
            if self.long_name is not None:
                option_string += ","
        else:
            option_string += "  "

        
        if self.long_name is not None: 
            option_string += " --" + self.long_name

        if self.arg_pattern != "":
            option_string += " {" + self.arg_pattern + "}"

        # Constrain the option string.
        temp_string, last_width, opt_lines = self.constrain_string(
            option_string, 
            option_width, 
            description_width + option_offset + description_offset, 
            1, 
            False)
        return help_string + temp_string + \
            "\n" * (min(1, opt_lines + desc_lines - 2) + 1)

    # TODO is first_offset_line a good name?
    # TODO lose the self so this can be used more generically.
    def constrain_string(self, base_string, constrained_width, line_offset_size=0, first_offset_line=0, use_dash=True):
        ''' Constrains a string to fit the supplied parameters, 
        this should be used in generating strings to fit the screen.
            
        Currently this function will do the following: Limit characters "per line", 
        offset each line greater than or equal to the `first_offset_line`, 
        and append dashes to tokens that are broken by new lines.
        
        :param string base_string: The string to constrain to fit the supplied parameters.
        :param int constrained_width: The number of characters to display per line. This 
            character total does **NOT** include `line_offset_size`.
        :param int line_offset_size: The number of spaces to append before the string on a 
            line. This amount has **NO** influence on `constrained_width`.
        :param int first_offset_line: Specifies the first line to apply the `line_offset_size` 
            offset to. This allows a string to be adjacent to another on the screen for a line.
        :param bool use_dash: Appends a '-' character when a token would be split 
            by the new line. This character will displace the last character on the line 
            to the next.

        :returns (string, int, int): Returns a tuple containing the constrained string, the 
            length of the last substring and the number of lines produced.
        '''

        constrained_string = ""               # The destination of the constraint.

        actual_width = len(base_string)       # The actual width of the base_string.
        substr_start = 0                      # Current start point of the base_string substring.
        substr_end   = constrained_width      # Current end point of the base_string substring.
        add_dash     = False                  # Helper flag for the base_string build.
        sub_str      = ""                     # The substring before adding to the constraint.
        offset_str   = " " * line_offset_size # The offset of the content string.
        current_line = 0                      # Current line number in constrained string.

        while substr_start < actual_width:
            # If the current character is not a space and either of the two surrounding it aren't either react.
            if (substr_end + 1) < actual_width and         \
              not base_string[substr_end].isspace() and     \
              ( not base_string[substr_end + 1].isspace() or \
                not base_string[substr_end - 1].isspace() ):
                # Drop this character to a newline 
                substr_end = substr_end - 1

                # Determine the start of the current token (space delimited), for processing.
                token_start = substr_end 
                while token_start > 0 and not base_string[token_start].isspace():
                    token_start -= 1

                # If this is a part of a token add a dash
                if not base_string[substr_end].isspace() and (substr_end - token_start) > 1:
                    add_dash = use_dash
            
            # Get rid of white space at the the start of the line.
            while base_string[substr_start].isspace() and \
                substr_start < actual_width:
                substr_start+=1

            # Build the current row.
            sub_str = base_string[substr_start:substr_end]

            # If the current line exceeds the first offset line
            if current_line >= first_offset_line: 
                constrained_string += offset_str
            constrained_string += sub_str

            if add_dash:
                add_dash = False
                constrained_string += "-"

            # Advance through the string. 
            substr_start = substr_end
            substr_end  += constrained_width
            if substr_start < actual_width:
                constrained_string += "\n"
            
            # Update the line number. 
            current_line += 1

        return ( constrained_string,  len(sub_str), current_line )
    
    def get_config_string(self):
        ''' Generates what a config file entry would look like for this element. The format of the output should look something like:

        .. code::

            ; `description`
            `config_name` : `default`

        :returns string: A string that could be used as a template for a configparser setting or a "" string if the element had no `config_name`.
        '''
        if self.config_name is None:
            return ""

        # Make sure lists are broken down.
        default_value = self.default
        if type(self.default) is list:
            default_value = ", ".join(str(x) for x in self.default) 
        
        return "\n; {0}. \n; Parameter Pattern: {1}\n{2}: {3}\n".format(
            self.description,
            self.arg_pattern,
            self.config_name, 
            default_value)

